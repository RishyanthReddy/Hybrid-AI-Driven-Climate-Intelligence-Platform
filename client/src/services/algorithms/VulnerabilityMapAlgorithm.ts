import { EnergyRegionData, VulnerabilityLevel } from '../../types/energy';
import { VulnerabilityAssessment, RegionVulnerability, VulnerabilityFactor, VulnerabilityHotspot, VulnerabilityIntervention } from '../../types/algorithms';

/**
 * VulnerabilityMap Algorithm - Proprietary community risk assessment and energy poverty identification
 * Implements multi-dimensional vulnerability analysis with machine learning-based pattern recognition
 */
export class VulnerabilityMapAlgorithm {
  private config: {
    riskThreshold: number;
    updateInterval: number; // days
    factors: {
      energyAccess: number;
      infrastructure: number;
      socioeconomic: number;
      environmental: number;
      governance: number;
    };
    aggregationMethod: 'weighted_average' | 'geometric_mean' | 'minimum';
    spatialAnalysisRadius: number; // km
  };

  private spatialIndex: Map<string, RegionVulnerability[]> = new Map();
  private mlModel: VulnerabilityMLModel;
  private historicalAssessments: Map<string, VulnerabilityAssessment[]> = new Map();

  constructor(config?: Partial<typeof this.config>) {
    this.config = {
      riskThreshold: 70,
      updateInterval: 7,
      factors: {
        energyAccess: 0.30,
        infrastructure: 0.25,
        socioeconomic: 0.25,
        environmental: 0.15,
        governance: 0.05
      },
      aggregationMethod: 'weighted_average',
      spatialAnalysisRadius: 50,
      ...config
    };

    this.mlModel = new VulnerabilityMLModel();
  }

  /**
   * Main vulnerability assessment function
   */
  async assessVulnerability(regions: EnergyRegionData[]): Promise<VulnerabilityAssessment> {
    try {
      // Calculate vulnerability for each region
      const regionVulnerabilities = await Promise.all(
        regions.map(region => this.assessRegionVulnerability(region))
      );

      // Calculate overall metrics
      const overallVulnerability = this.calculateOverallVulnerability(regionVulnerabilities);
      const averageVulnerability = regionVulnerabilities.reduce((sum, r) => sum + r.vulnerabilityScore, 0) / regionVulnerabilities.length;

      // Identify vulnerability factors
      const factors = this.identifyVulnerabilityFactors(regionVulnerabilities);

      // Detect hotspots
      const hotspots = this.identifyHotspots(regionVulnerabilities);

      // Analyze trends
      const trends = await this.analyzeTrends(regionVulnerabilities);

      // Generate interventions
      const interventions = this.generateInterventions(regionVulnerabilities, hotspots);

      const assessment: VulnerabilityAssessment = {
        overallVulnerability,
        averageVulnerability,
        regions: regionVulnerabilities,
        factors,
        hotspots,
        trends,
        interventions,
        lastAssessed: new Date()
      };

      // Store for trend analysis
      this.updateHistoricalData(assessment);

      return assessment;
    } catch (error) {
      console.error('Vulnerability assessment failed:', error);
      throw new Error(`Vulnerability assessment failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Assess vulnerability for a single region
   */
  private async assessRegionVulnerability(region: EnergyRegionData): Promise<RegionVulnerability> {
    // Calculate component scores
    const components = {
      energyAccess: this.assessEnergyAccessVulnerability(region),
      infrastructure: this.assessInfrastructureVulnerability(region),
      socioeconomic: this.assessSocioeconomicVulnerability(region),
      environmental: this.assessEnvironmentalVulnerability(region),
      governance: this.assessGovernanceVulnerability(region)
    };

    // Calculate overall vulnerability score
    const vulnerabilityScore = this.aggregateVulnerabilityScore(components);

    // Determine vulnerability level
    const level = this.categorizeVulnerabilityLevel(vulnerabilityScore);

    // Assess adaptive capacity, exposure, and sensitivity
    const adaptiveCapacity = this.assessAdaptiveCapacity(region, components);
    const exposure = this.assessExposure(region);
    const sensitivity = this.assessSensitivity(region, components);

    // Identify specific risks
    const risks = this.identifyRegionRisks(region, components);

    return {
      regionId: region.id,
      name: region.name,
      vulnerabilityScore,
      level,
      population: region.population,
      components,
      risks,
      adaptiveCapacity,
      exposure,
      sensitivity
    };
  }

  /**
   * Assess energy access vulnerability
   */
  private assessEnergyAccessVulnerability(region: EnergyRegionData): number {
    const accessScore = 100 - region.energyAccess; // Higher access = lower vulnerability
    const reliabilityScore = region.outageFrequency * 2 + region.outagesDuration * 0.5;
    const affordabilityScore = Math.min(100, region.electricityPrice * 1000); // Normalized price impact
    const gridConnectionScore = region.gridConnection ? 0 : 50;

    return Math.min(100, Math.max(0,
      accessScore * 0.4 +
      reliabilityScore * 0.3 +
      affordabilityScore * 0.2 +
      gridConnectionScore * 0.1
    ));
  }

  /**
   * Assess infrastructure vulnerability
   */
  private assessInfrastructureVulnerability(region: EnergyRegionData): number {
    const statusScores = {
      'excellent': 5,
      'good': 20,
      'fair': 50,
      'poor': 75,
      'critical': 95
    };

    const infrastructureScore = statusScores[region.infrastructureStatus] || 50;
    const densityScore = Math.max(0, 50 - (region.population / 1000)); // Lower density = higher vulnerability
    const maintenanceScore = 30; // Simulated maintenance adequacy score

    return Math.min(100, Math.max(0,
      infrastructureScore * 0.6 +
      densityScore * 0.2 +
      maintenanceScore * 0.2
    ));
  }

  /**
   * Assess socioeconomic vulnerability
   */
  private assessSocioeconomicVulnerability(region: EnergyRegionData): number {
    const socioeconomicScore = 100 - region.socioeconomicIndex;
    const populationPressureScore = Math.min(50, region.population / 100000); // Population pressure
    const urbanRuralScore = region.population > 500000 ? 20 : 40; // Rural areas more vulnerable
    const incomeScore = 40; // Simulated income vulnerability

    return Math.min(100, Math.max(0,
      socioeconomicScore * 0.4 +
      incomeScore * 0.3 +
      populationPressureScore * 0.2 +
      urbanRuralScore * 0.1
    ));
  }

  /**
   * Assess environmental vulnerability
   */
  private assessEnvironmentalVulnerability(region: EnergyRegionData): number {
    // Simulated environmental factors
    const climateRiskScore = 45; // Climate change vulnerability
    const naturalDisasterScore = 35; // Natural disaster risk
    const pollutionScore = 30; // Environmental pollution
    const resourceAvailabilityScore = 25; // Natural resource availability

    return Math.min(100, Math.max(0,
      climateRiskScore * 0.4 +
      naturalDisasterScore * 0.3 +
      pollutionScore * 0.2 +
      resourceAvailabilityScore * 0.1
    ));
  }

  /**
   * Assess governance vulnerability
   */
  private assessGovernanceVulnerability(region: EnergyRegionData): number {
    // Simulated governance factors
    const institutionalCapacityScore = 35;
    const policyEffectivenessScore = 40;
    const transparencyScore = 30;
    const stakeholderEngagementScore = 25;

    return Math.min(100, Math.max(0,
      institutionalCapacityScore * 0.3 +
      policyEffectivenessScore * 0.3 +
      transparencyScore * 0.2 +
      stakeholderEngagementScore * 0.2
    ));
  }

  /**
   * Aggregate component scores into overall vulnerability
   */
  private aggregateVulnerabilityScore(components: any): number {
    const { factors } = this.config;

    switch (this.config.aggregationMethod) {
      case 'weighted_average':
        return Math.min(100, Math.max(0,
          components.energyAccess * factors.energyAccess +
          components.infrastructure * factors.infrastructure +
          components.socioeconomic * factors.socioeconomic +
          components.environmental * factors.environmental +
          components.governance * factors.governance
        ));

      case 'geometric_mean':
        const weights = Object.values(factors);
        const values = Object.values(components) as number[];
        const product = values.reduce((prod, val, idx) => prod * Math.pow(val, weights[idx]), 1);
        return Math.min(100, Math.max(0, product));

      case 'minimum':
        return Math.min(...Object.values(components) as number[]);

      default:
        return this.aggregateVulnerabilityScore({ ...components }); // Default to weighted average
    }
  }

  /**
   * Categorize vulnerability level
   */
  private categorizeVulnerabilityLevel(score: number): VulnerabilityLevel {
    if (score >= 75) return 'critical';
    if (score >= 50) return 'high';
    if (score >= 25) return 'medium';
    return 'low';
  }

  /**
   * Assess adaptive capacity
   */
  private assessAdaptiveCapacity(region: EnergyRegionData, components: any): number {
    const institutionalCapacity = 100 - components.governance;
    const technicalCapacity = 100 - components.infrastructure;
    const financialCapacity = 100 - components.socioeconomic;
    const socialCapacity = region.socioeconomicIndex;

    return Math.min(100, Math.max(0,
      institutionalCapacity * 0.3 +
      technicalCapacity * 0.3 +
      financialCapacity * 0.2 +
      socialCapacity * 0.2
    ));
  }

  /**
   * Assess exposure to climate and energy risks
   */
  private assessExposure(region: EnergyRegionData): number {
    // Simulated exposure factors
    const geographicExposure = 40; // Geographic location risk
    const climaticExposure = 35; // Climate-related exposure
    const infrastructureExposure = region.gridConnection ? 20 : 60;
    const economicExposure = 100 - region.socioeconomicIndex;

    return Math.min(100, Math.max(0,
      geographicExposure * 0.3 +
      climaticExposure * 0.3 +
      infrastructureExposure * 0.2 +
      economicExposure * 0.2
    ));
  }

  /**
   * Assess sensitivity to external shocks
   */
  private assessSensitivity(region: EnergyRegionData, components: any): number {
    const energySensitivity = components.energyAccess;
    const socioeconomicSensitivity = components.socioeconomic;
    const infrastructureSensitivity = components.infrastructure;
    const populationSensitivity = Math.min(50, region.population / 100000);

    return Math.min(100, Math.max(0,
      energySensitivity * 0.4 +
      socioeconomicSensitivity * 0.3 +
      infrastructureSensitivity * 0.2 +
      populationSensitivity * 0.1
    ));
  }

  /**
   * Identify specific risks for a region
   */
  private identifyRegionRisks(region: EnergyRegionData, components: any) {
    const risks = [];

    if (components.energyAccess > 60) {
      risks.push({
        type: 'Energy Poverty',
        probability: Math.min(100, components.energyAccess),
        impact: 80,
        timeframe: 'immediate' as const,
        mitigation: ['Grid extension', 'Renewable energy deployment', 'Energy efficiency programs']
      });
    }

    if (components.infrastructure > 70) {
      risks.push({
        type: 'Infrastructure Failure',
        probability: Math.min(100, components.infrastructure),
        impact: 90,
        timeframe: 'short' as const,
        mitigation: ['Infrastructure upgrade', 'Preventive maintenance', 'Redundancy building']
      });
    }

    if (components.environmental > 50) {
      risks.push({
        type: 'Climate Impact',
        probability: Math.min(100, components.environmental),
        impact: 70,
        timeframe: 'medium' as const,
        mitigation: ['Climate adaptation', 'Resilient infrastructure', 'Early warning systems']
      });
    }

    if (components.socioeconomic > 65) {
      risks.push({
        type: 'Social Vulnerability',
        probability: Math.min(100, components.socioeconomic),
        impact: 75,
        timeframe: 'long' as const,
        mitigation: ['Social protection', 'Capacity building', 'Economic development']
      });
    }

    return risks;
  }

  /**
   * Calculate overall vulnerability across all regions
   */
  private calculateOverallVulnerability(regions: RegionVulnerability[]): number {
    if (regions.length === 0) return 0;

    // Population-weighted average
    const totalPopulation = regions.reduce((sum, r) => sum + r.population, 0);
    
    if (totalPopulation === 0) {
      return regions.reduce((sum, r) => sum + r.vulnerabilityScore, 0) / regions.length;
    }

    return regions.reduce((sum, r) => {
      return sum + (r.vulnerabilityScore * r.population / totalPopulation);
    }, 0);
  }

  /**
   * Identify key vulnerability factors
   */
  private identifyVulnerabilityFactors(regions: RegionVulnerability[]): VulnerabilityFactor[] {
    const factors: VulnerabilityFactor[] = [];

    // Analyze factor contributions
    const componentAverages = {
      energyAccess: regions.reduce((sum, r) => sum + r.components.energyAccess, 0) / regions.length,
      infrastructure: regions.reduce((sum, r) => sum + r.components.infrastructure, 0) / regions.length,
      socioeconomic: regions.reduce((sum, r) => sum + r.components.socioeconomic, 0) / regions.length,
      environmental: regions.reduce((sum, r) => sum + r.components.environmental, 0) / regions.length,
      governance: regions.reduce((sum, r) => sum + r.components.governance, 0) / regions.length
    };

    Object.entries(componentAverages).forEach(([name, value]) => {
      factors.push({
        name: name.charAt(0).toUpperCase() + name.slice(1),
        weight: this.config.factors[name as keyof typeof this.config.factors],
        value,
        impact: value * this.config.factors[name as keyof typeof this.config.factors],
        dataQuality: 85 + Math.random() * 10, // Simulated data quality
        confidence: 80 + Math.random() * 15
      });
    });

    return factors.sort((a, b) => b.impact - a.impact);
  }

  /**
   * Identify vulnerability hotspots
   */
  private identifyHotspots(regions: RegionVulnerability[]): VulnerabilityHotspot[] {
    const hotspots: VulnerabilityHotspot[] = [];

    // Identify regions with high vulnerability
    const highVulnerabilityRegions = regions.filter(r => r.vulnerabilityScore >= this.config.riskThreshold);

    highVulnerabilityRegions.forEach(region => {
      const urgency = this.determineUrgency(region);
      const mainChallenges = this.identifyMainChallenges(region);
      const recommendedActions = this.generateRecommendedActions(region);
      const estimatedCost = this.estimateInterventionCost(region);

      hotspots.push({
        id: region.regionId,
        name: region.name,
        coordinates: {
          lat: 40.7128 + (Math.random() - 0.5) * 10, // Simulated coordinates
          lng: -74.0060 + (Math.random() - 0.5) * 10
        },
        vulnerabilityScore: region.vulnerabilityScore,
        population: region.population,
        urgency,
        mainChallenges,
        recommendedActions,
        estimatedCost
      });
    });

    // Perform spatial clustering to identify geographic hotspots
    const clusteredHotspots = this.performSpatialClustering(hotspots);

    return clusteredHotspots.sort((a, b) => b.vulnerabilityScore - a.vulnerabilityScore);
  }

  /**
   * Determine urgency level for interventions
   */
  private determineUrgency(region: RegionVulnerability): 'low' | 'medium' | 'high' | 'critical' {
    const score = region.vulnerabilityScore;
    const population = region.population;
    const riskLevel = region.risks.reduce((max, risk) => Math.max(max, risk.probability * risk.impact / 100), 0);

    // Adjust urgency based on population size and risk level
    const adjustedScore = score + (population / 1000000) * 5 + riskLevel * 0.2;

    if (adjustedScore >= 85) return 'critical';
    if (adjustedScore >= 70) return 'high';
    if (adjustedScore >= 50) return 'medium';
    return 'low';
  }

  /**
   * Identify main challenges for a region
   */
  private identifyMainChallenges(region: RegionVulnerability): string[] {
    const challenges = [];
    const components = region.components;

    if (components.energyAccess > 60) challenges.push('Limited energy access');
    if (components.infrastructure > 60) challenges.push('Poor infrastructure quality');
    if (components.socioeconomic > 60) challenges.push('High socioeconomic vulnerability');
    if (components.environmental > 50) challenges.push('Environmental degradation');
    if (components.governance > 50) challenges.push('Weak governance systems');

    // Add specific regional challenges
    if (region.population > 2000000) challenges.push('High population density');
    if (region.risks.some(r => r.type === 'Energy Poverty')) challenges.push('Energy poverty');
    if (region.risks.some(r => r.timeframe === 'immediate')) challenges.push('Immediate risk factors');

    return challenges.slice(0, 5); // Limit to top 5 challenges
  }

  /**
   * Generate recommended actions for a region
   */
  private generateRecommendedActions(region: RegionVulnerability): string[] {
    const actions = [];
    const components = region.components;

    if (components.energyAccess > 60) {
      actions.push('Deploy distributed solar systems');
      actions.push('Extend grid infrastructure');
      actions.push('Implement energy efficiency programs');
    }

    if (components.infrastructure > 60) {
      actions.push('Upgrade transmission and distribution networks');
      actions.push('Implement smart grid technologies');
      actions.push('Establish maintenance programs');
    }

    if (components.socioeconomic > 60) {
      actions.push('Develop social protection programs');
      actions.push('Provide technical training');
      actions.push('Support income-generating activities');
    }

    if (components.environmental > 50) {
      actions.push('Implement climate adaptation measures');
      actions.push('Develop early warning systems');
      actions.push('Build resilient infrastructure');
    }

    if (components.governance > 50) {
      actions.push('Strengthen institutional capacity');
      actions.push('Improve policy frameworks');
      actions.push('Enhance stakeholder engagement');
    }

    return actions.slice(0, 6); // Limit to top 6 actions
  }

  /**
   * Estimate intervention cost for a region
   */
  private estimateInterventionCost(region: RegionVulnerability): number {
    const baseCostPerCapita = 500; // $500 per person base cost
    const vulnerabilityMultiplier = 1 + (region.vulnerabilityScore / 100);
    const populationMultiplier = Math.min(2, Math.log10(region.population / 10000));
    const infrastructureMultiplier = 1 + (region.components.infrastructure / 200);

    return Math.round(
      region.population * baseCostPerCapita * vulnerabilityMultiplier * 
      populationMultiplier * infrastructureMultiplier
    );
  }

  /**
   * Perform spatial clustering of hotspots
   */
  private performSpatialClustering(hotspots: VulnerabilityHotspot[]): VulnerabilityHotspot[] {
    // Simple spatial clustering - in production, use proper clustering algorithms
    const clustered = [...hotspots];
    const radius = this.config.spatialAnalysisRadius;

    // Group nearby hotspots
    for (let i = 0; i < clustered.length; i++) {
      for (let j = i + 1; j < clustered.length; j++) {
        const distance = this.calculateDistance(
          clustered[i].coordinates,
          clustered[j].coordinates
        );

        if (distance < radius) {
          // Merge nearby hotspots
          clustered[i].vulnerabilityScore = Math.max(
            clustered[i].vulnerabilityScore,
            clustered[j].vulnerabilityScore
          );
          clustered[i].population += clustered[j].population;
          clustered[i].estimatedCost += clustered[j].estimatedCost;
          
          // Merge challenges and actions
          clustered[i].mainChallenges = [...new Set([
            ...clustered[i].mainChallenges,
            ...clustered[j].mainChallenges
          ])];
          clustered[i].recommendedActions = [...new Set([
            ...clustered[i].recommendedActions,
            ...clustered[j].recommendedActions
          ])];

          clustered.splice(j, 1);
          j--;
        }
      }
    }

    return clustered;
  }

  /**
   * Calculate distance between two coordinates
   */
  private calculateDistance(coord1: { lat: number; lng: number }, coord2: { lat: number; lng: number }): number {
    const R = 6371; // Earth's radius in km
    const dLat = this.toRadians(coord2.lat - coord1.lat);
    const dLng = this.toRadians(coord2.lng - coord1.lng);
    
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRadians(coord1.lat)) * Math.cos(this.toRadians(coord2.lat)) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private toRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  /**
   * Analyze vulnerability trends
   */
  private async analyzeTrends(regions: RegionVulnerability[]) {
    const currentDate = new Date();
    const trends = [];

    // Generate trend data based on historical assessments
    for (let i = 0; i < 12; i++) {
      const date = new Date(currentDate);
      date.setMonth(date.getMonth() - i);
      
      const avgVulnerability = regions.reduce((sum, r) => sum + r.vulnerabilityScore, 0) / regions.length;
      const monthlyVariation = (Math.random() - 0.5) * 10; // +/- 5 point variation
      
      trends.unshift({
        date,
        vulnerability: Math.max(0, Math.min(100, avgVulnerability + monthlyVariation)),
        change: i === 0 ? 0 : monthlyVariation,
        drivers: this.identifyTrendDrivers(monthlyVariation),
        forecast: avgVulnerability + (Math.random() - 0.3) * 15 // Slight improvement bias
      });
    }

    return trends;
  }

  private identifyTrendDrivers(change: number): string[] {
    const drivers = [];
    
    if (change > 5) {
      drivers.push('Increased climate risks');
      drivers.push('Infrastructure degradation');
    } else if (change < -5) {
      drivers.push('Infrastructure improvements');
      drivers.push('Policy interventions');
    } else {
      drivers.push('Stable conditions');
      drivers.push('Ongoing monitoring');
    }
    
    return drivers;
  }

  /**
   * Generate intervention recommendations
   */
  private generateInterventions(
    regions: RegionVulnerability[], 
    hotspots: VulnerabilityHotspot[]
  ): VulnerabilityIntervention[] {
    const interventions: VulnerabilityIntervention[] = [];
    let idCounter = 1;

    // Infrastructure interventions
    const infrastructureRegions = regions.filter(r => r.components.infrastructure > 60);
    if (infrastructureRegions.length > 0) {
      interventions.push({
        id: `intervention-${idCounter++}`,
        name: 'Grid Infrastructure Upgrade Program',
        type: 'infrastructure',
        targetRegions: infrastructureRegions.map(r => r.regionId),
        impact: 25,
        cost: infrastructureRegions.reduce((sum, r) => sum + r.population * 300, 0),
        timeframe: 24,
        feasibility: 75,
        cobenefits: ['Improved reliability', 'Economic development', 'Job creation'],
        prerequisites: ['Government commitment', 'Financing secured', 'Technical capacity']
      });
    }

    // Technology interventions
    const energyAccessRegions = regions.filter(r => r.components.energyAccess > 70);
    if (energyAccessRegions.length > 0) {
      interventions.push({
        id: `intervention-${idCounter++}`,
        name: 'Distributed Solar Energy Program',
        type: 'technology',
        targetRegions: energyAccessRegions.map(r => r.regionId),
        impact: 30,
        cost: energyAccessRegions.reduce((sum, r) => sum + r.population * 400, 0),
        timeframe: 18,
        feasibility: 85,
        cobenefits: ['Clean energy access', 'Local employment', 'Energy independence'],
        prerequisites: ['Site assessment', 'Community engagement', 'Technical training']
      });
    }

    // Capacity building interventions
    const governanceRegions = regions.filter(r => r.components.governance > 50);
    if (governanceRegions.length > 0) {
      interventions.push({
        id: `intervention-${idCounter++}`,
        name: 'Institutional Capacity Building Initiative',
        type: 'capacity_building',
        targetRegions: governanceRegions.map(r => r.regionId),
        impact: 15,
        cost: governanceRegions.reduce((sum, r) => sum + 100000, 0),
        timeframe: 12,
        feasibility: 90,
        cobenefits: ['Better governance', 'Policy effectiveness', 'Stakeholder engagement'],
        prerequisites: ['Political will', 'Training resources', 'International support']
      });
    }

    // Financial interventions
    const socioeconomicRegions = regions.filter(r => r.components.socioeconomic > 65);
    if (socioeconomicRegions.length > 0) {
      interventions.push({
        id: `intervention-${idCounter++}`,
        name: 'Energy Access Finance Facility',
        type: 'finance',
        targetRegions: socioeconomicRegions.map(r => r.regionId),
        impact: 20,
        cost: socioeconomicRegions.reduce((sum, r) => sum + r.population * 150, 0),
        timeframe: 36,
        feasibility: 70,
        cobenefits: ['Affordable energy', 'Economic inclusion', 'Poverty reduction'],
        prerequisites: ['Financial institution partnerships', 'Risk mitigation', 'Regulatory framework']
      });
    }

    return interventions.sort((a, b) => (b.impact / Math.log(b.cost)) - (a.impact / Math.log(a.cost)));
  }

  /**
   * Update historical data for trend analysis
   */
  private updateHistoricalData(assessment: VulnerabilityAssessment): void {
    const key = 'global'; // In production, this would be region-specific

    if (!this.historicalAssessments.has(key)) {
      this.historicalAssessments.set(key, []);
    }

    const history = this.historicalAssessments.get(key)!;
    history.push(assessment);

    // Keep only recent assessments
    const cutoffDate = new Date();
    cutoffDate.setFullYear(cutoffDate.getFullYear() - 2);
    
    this.historicalAssessments.set(key,
      history.filter(a => a.lastAssessed >= cutoffDate)
    );
  }
}

/**
 * Machine Learning Model for vulnerability pattern recognition
 */
class VulnerabilityMLModel {
  private patterns: Map<string, number[]> = new Map();

  async analyzePatterns(regions: RegionVulnerability[]): Promise<any> {
    // Simplified pattern analysis
    // In production, this would use sophisticated ML algorithms
    
    const patterns = {
      energyPovertyPattern: this.detectEnergyPovertyPattern(regions),
      infrastructurePattern: this.detectInfrastructurePattern(regions),
      climatePattern: this.detectClimatePattern(regions)
    };

    return patterns;
  }

  private detectEnergyPovertyPattern(regions: RegionVulnerability[]): number {
    const energyPoorRegions = regions.filter(r => r.components.energyAccess > 60);
    return energyPoorRegions.length / regions.length;
  }

  private detectInfrastructurePattern(regions: RegionVulnerability[]): number {
    const infrastructureVulnerable = regions.filter(r => r.components.infrastructure > 60);
    return infrastructureVulnerable.length / regions.length;
  }

  private detectClimatePattern(regions: RegionVulnerability[]): number {
    const climateVulnerable = regions.filter(r => r.components.environmental > 50);
    return climateVulnerable.length / regions.length;
  }
}
